/*
 *  Copyright 2016, Yahoo Inc.
 *  Licensed under the terms of the Apache License, Version 2.0.
 *  See the LICENSE file associated with the project for terms.
 */
package com.yahoo.bullet.storm;

import lombok.Getter;
import lombok.Setter;
import org.apache.storm.tuple.Tuple;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static com.yahoo.bullet.storm.TopologyConstants.DATA_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.ERROR_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.FEEDBACK_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.FILTER_COMPONENT;
import static com.yahoo.bullet.storm.TopologyConstants.JOIN_COMPONENT;
import static com.yahoo.bullet.storm.TopologyConstants.METADATA_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.QUERY_COMPONENT;
import static com.yahoo.bullet.storm.TopologyConstants.QUERY_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.RECORD_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.REPLAY_COMPONENT;
import static com.yahoo.bullet.storm.TopologyConstants.REPLAY_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.RESULT_STREAM;
import static com.yahoo.bullet.storm.TopologyConstants.TICK_COMPONENT;
import static com.yahoo.bullet.storm.TopologyConstants.TICK_STREAM;

public class TupleClassifier {
    @Getter
    public enum Type {
        TICK_TUPLE(TICK_COMPONENT, TICK_STREAM),
        QUERY_TUPLE(QUERY_COMPONENT, QUERY_STREAM),
        METADATA_TUPLE(QUERY_COMPONENT, METADATA_STREAM),
        RECORD_TUPLE(null, RECORD_STREAM),
        ERROR_TUPLE(FILTER_COMPONENT, ERROR_STREAM),
        DATA_TUPLE(FILTER_COMPONENT, DATA_STREAM),
        RESULT_TUPLE(JOIN_COMPONENT, RESULT_STREAM),
        FEEDBACK_TUPLE(JOIN_COMPONENT, FEEDBACK_STREAM),
        REPLAY_TUPLE(QUERY_COMPONENT, REPLAY_STREAM),
        BATCH_TUPLE(REPLAY_COMPONENT, REPLAY_STREAM),
        UNKNOWN_TUPLE("", "");

        private String stream;
        private String component;

        Type(String component, String stream) {
            this.component = component;
            this.stream = stream;
        }

        /**
         * Returns true iff the given tuple is of this Type.
         *
         * @param tuple The tuple to check for.
         * @return A boolean denoting whether this tuple is of this Type.
         */
        public boolean isMe(Tuple tuple) {
            return isEqualIfSet(component, tuple.getSourceComponent()) && isEqualIfSet(stream, tuple.getSourceStreamId());
        }

        private boolean isEqualIfSet(String field, String value) {
            return field == null || value.equals(field);
        }
    }

    // These are the types generated by us.
    private static final List<Type> INTERNAL_TYPES =
        Arrays.asList(Type.TICK_TUPLE, Type.QUERY_TUPLE, Type.METADATA_TUPLE, Type.ERROR_TUPLE, Type.DATA_TUPLE,
                      Type.RESULT_TUPLE, Type.FEEDBACK_TUPLE, Type.REPLAY_TUPLE, Type.BATCH_TUPLE);

    @Setter
    private String recordComponent = TopologyConstants.RECORD_COMPONENT;

    /**
     * Returns the {@link TupleClassifier.Type} of this tuple. If you have a custom record component name, you should
     * use setRecordComponent(String) first. Otherwise, the default value of {@link TopologyConstants#RECORD_COMPONENT}
     * is used. The type returned will never be a {@link Type#UNKNOWN_TUPLE}. See {@link #classifyInternalTypes(Tuple)}
     * if you will not be passing in {@link Type#RECORD_TUPLE} tuples.
     *
     * @param tuple The tuple whose type is needed.
     * @return An {@link Optional} {@link TupleClassifier.Type} for the tuple.
     */
    public Optional<Type> classify(Tuple tuple) {
        return recordComponent.equals(tuple.getSourceComponent()) ? Optional.of(Type.RECORD_TUPLE) : classifyInternalTypes(tuple);
    }

    /**
     * Returns the {@link Type} of this tuple. It will never be a {@link Type#RECORD_TUPLE} or a
     * {@link Type#UNKNOWN_TUPLE}. See {@link #classify(Tuple)} for full classification.
     *
     * @param tuple The tuple whose type is needed.
     * @return An {@link Optional} {@link Type} for the tuple.
     */
    public Optional<Type> classifyInternalTypes(Tuple tuple) {
        return INTERNAL_TYPES.stream().filter(x -> x.isMe(tuple)).findFirst();
    }
}
